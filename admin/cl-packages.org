# -*- mode: org; eval: (auto-fill-mode 1); org-indent-mode: 1; -*-
#+STARTUP: show3levels

* Common Lisp packages for Emacs

This is an experimental implementation of CL packages for Emacs.
The question of the experiment is if it is possible to add CL packages
to Emacs with reasonable effort and reasonable compatibility.

Note that this branch is only known to build and run under macOS.  I
don't have access to other systems, so it might not compile or work on
other systems.  Patches welcome.

Please see a book like Common Lisp the Language (CLtL2) for a
description of the CL package systen.  The book is freely available
from CMU.

** Status
This builds and runs with unchanged Magit, Lsp-mode, and other
packages for me, so it seems to be pretty backwards-compatible.  I
can't gurantee anything, of course.  If you find a problem, please let
me know.

** User-visible functionality
There are three pre-defined packages.

The keyword package, named "keyword" or "" contains keywords.

The Emacs package, with name "emacs" contains all other symbols.  All
code is currently loaded in this package, for compatibility.  All
symbols in the package are currently exported.

The "emacs-user" package is intended for user-code, for example in
*scratch*, and uses the Emacs package, so that everything in Emacs can
be used.

These variables are defined:

"*package*" holds the current package like in CL.  It's buffer-local,
and you can't set it to a non-package value, to prevent havoc.

"*emacs-package*", "*keyword-package*", "*emacs-user-package*" hold
the package objects.  This is mainly for easier debugging and testing.
The variables may go at some point.  Or not.

"*package-registry* is a hash-table of registered packages.  The
variable may go at some point.  Or not.

Various functions related to packages are defined.  Depending on the
time when you read this, this may be in some state of incompleteness,
and it probably has bugs.  Reports or fixes welcome.

** Implementation notes
*** Where is it?
The C part is in src/pkg.c.  I chose that name because package.c
resulted in conflicts in the tests (with package.el).

The Lisp part is in lisp/emacs-lisp/pkg.el.  I've done as much of this
in Lisp because that's much easier and faster.  If packages are used
in files loaded in loadup, changes might be necessary to make this
possible.  I consider this out of scope, ATM.

*** No pure space support
The branch contains a patch by Stefan Monnier that makes it no longer
use pure space.  I didn't want to deal with pure space.  Note that a
small fix in init_vectors is needed for making Stefan's patch work.
There is nothing preventing the use of pure space though, in
principle.

*** Shorthands
Are currently not supported.  I understand what they do
but I don't understand their end-purpose.

*** Lisp_Package
There is a new Lisp data type Lisp_Package defined in lisp.h.

***  Lisp_Symbol
Struct Lisp_Symbol has lost its interned flag and its next pointer.
Both were an implementation detail of obarrays, which are gone.

All symbols now have a package.  Uninterned symbols have a nil
package.

Keywords have the keyword package. Note that keyword symbol names do
not contain the colon.  The function symbol-name still returns a
string with a leading colon.  I found this was necessary to achieve
backwards-compatibility.  At least at this point.  The function
cl-symbol-name returns the real name of a keyword, without the colon.

Other symbols have the Emacs package.

*** Obarrays
Obarrays have been removed.  Backwards-compatibility is achieved by
the following

- The variable 'obarray' still exists.  Its value is now the Emacs
  package.
- intern, intern-soft, unintern, mapatoms still accept vectors (former
  obarrays).  When called with a vector, they secretly create and use
  packages.  This is done because legacy code uses make-vector instead
  of obarray-make to create obarrays.

*** Reader
The variable 'package-prefixes' determines if the reader will
interpret colons in a symbol name as part of a package name or not.
Default is nil.

*** Printer
The printer prints package prefixes if necessary, as in CL.

*** Completions
The completion functions accept packages as collections.

** Problems and how they are approached (currently)
*** Keywords
In CL, keywords are symbols in the keyword package.  The leading colon
of a keyword is not part of its symbol name, but a package prefix.
The keyword package has a nickname that is an empty string.

In Emacs, keywords are just symbols whose names start with a colon,
and that is expected in a ton of places both implicity and explicitly
in various ways.

Solution:

- Internally, keyword names don't contain the colon, which is TRT.
- symbol-name returns a name with colon for keywords.
- cl-symbol-name returns the symbol name as-is.
- intern and intern-soft when called with a name starting with a colon
  interpret that as wanting a keyword.

*** Fake package qualification
Existing code contains symbols like GUI:xyz which look like GUI is a
package qualification.  That's the reason for package-prefixes which
means to interpret the : as part of the symbol name.

** Ideas / Todo
*** Completions
It might be useful to complete over all symbols in all packages.
I haven't added that.

*** Existing package extensions
There are some language extensions available in CL implementations
that might be nice to have:

*** Changing symbol names
A trap that I always fall into, constantly, in Emacs, is to use CL
functions without the cl- prefix.  It would be nice to have something
that makes these symbols available without the cl-.

Just ideas:

- (shadow-alias multiple-value-bind cl-multiple-value-bind) or maybe
  with regexs. Or something.
- (import sym as another-sym)

*** Package-prefixes
Would it make sense to record the value of package-prefixes when read
or compiled in functions?  This would allow some notorious cases of
intern, for example, which use colons in the traditional way to behave
differently.

This could also be used for symbol-name, which would only return a
name with leading colon if package-prefixes is nil.

*** Modeline
A mode-line indicator showing the current package and package-prefixes
would be nice.  Can be done with (:eval ...) in global-mode-string
now.

*** Tests
Should be much improved.
*** Documentation
Doesn't exist :-).
*** Other
- Add (declare (ignore ...)) and (declare (ignorable ...) goddam :-).
